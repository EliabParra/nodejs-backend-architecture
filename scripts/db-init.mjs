import 'dotenv/config'

import readline from 'node:readline/promises'
import { stdin as input, stdout as output } from 'node:process'
import path from 'node:path'
import fs from 'node:fs/promises'
import { pathToFileURL } from 'node:url'

import pg from 'pg'
import bcrypt from 'bcryptjs'
import { createRequire } from 'node:module'

const require = createRequire(import.meta.url)

function envBool(value) {
    if (value == null) return undefined
    const v = String(value).trim().toLowerCase()
    if (['1', 'true', 'yes', 'y', 'on'].includes(v)) return true
    if (['0', 'false', 'no', 'n', 'off'].includes(v)) return false
    return undefined
}

function envInt(value) {
    if (value == null) return undefined
    const n = Number.parseInt(String(value), 10)
    return Number.isFinite(n) ? n : undefined
}

function parseArgs(argv) {
    const args = []
    const opts = {}
    for (let i = 0; i < argv.length; i++) {
        const a = argv[i]
        if (a.startsWith('--')) {
            const key = a.slice(2)
            const next = argv[i + 1]
            if (next == null || next.startsWith('--')) {
                opts[key] = true
            } else {
                opts[key] = next
                i++
            }
        } else {
            args.push(a)
        }
    }
    return { args, opts }
}

function isTty() {
    return Boolean(process.stdin.isTTY && process.stdout.isTTY)
}

function normalizeSchemaName(value) {
    const s = String(value ?? '').trim()
    return s.length > 0 ? s : undefined
}

function normalizeTableName(value) {
    const s = String(value ?? '').trim()
    return s.length > 0 ? s : undefined
}

function printHelp() {
    console.log(`
DB Init CLI

Usage:
  npm run db:init
  node scripts/db-init.mjs [options]

Options:
  --apply                 Apply changes to the DB (default in TTY)
  --print                 Print SQL only (no DB changes)
  --yes                   Non-interactive (assume yes for prompts)

  --sessionSchema <name>  Session table schema (default: public)
  --sessionTable <name>   Session table name (default: session)

  --includeEmail          Add optional security.user.user_em column
  --seedAdmin             Create/update an admin user + profile (default in TTY)
  --adminUser <name>      Admin username (default: admin)
  --adminPassword <pw>    Admin password (will be bcrypt-hashed)
  --profileId <id>        Profile id to link to admin (default: 1)

	--registerBo            Auto-register BO methods into security.method (default in TTY)
	--txStart <n>           Starting tx for new methods (default: max(tx)+1)

DB connection:
  Uses DATABASE_URL when set; otherwise PG* vars; otherwise src/config/config.json.
`)
}

function loadDbConfig() {
    const cfg = require('../src/config/config.json')
    const db = { ...(cfg.db ?? {}) }

    // Supports standard PG* vars and DATABASE_URL.
    if (process.env.DATABASE_URL) db.connectionString = process.env.DATABASE_URL
    if (process.env.PGHOST) db.host = process.env.PGHOST
    if (process.env.PGPORT) {
        const port = envInt(process.env.PGPORT)
        if (port != null) db.port = port
    }
    if (process.env.PGDATABASE) db.database = process.env.PGDATABASE
    if (process.env.PGUSER) db.user = process.env.PGUSER
    if (process.env.PGPASSWORD) db.password = process.env.PGPASSWORD
    const pgSsl = envBool(process.env.PGSSL)
    if (pgSsl != null) db.ssl = pgSsl

    return db
}

function pgClientConfig(db) {
    // pg accepts either connectionString or host/user/password/etc.
    if (db.connectionString) {
        return {
            connectionString: db.connectionString,
            ssl: db.ssl ? { rejectUnauthorized: false } : false,
        }
    }
    return {
        host: db.host,
        port: db.port,
        database: db.database,
        user: db.user,
        password: db.password,
        ssl: db.ssl ? { rejectUnauthorized: false } : false,
    }
}

function sqlSecuritySchemaBase() {
    return [
        `create schema if not exists security;`,
        `create table if not exists security.profile (\n  profile_id bigint generated by default as identity primary key\n);`,
        `create table if not exists security."user" (\n  user_id bigint generated by default as identity primary key,\n  user_na text not null unique,\n  user_pw text not null\n);`,
        `create table if not exists security.user_profile (\n  user_id bigint not null references security."user"(user_id) on delete cascade,\n  profile_id bigint not null references security.profile(profile_id) on delete cascade,\n  primary key (user_id, profile_id)\n);`,
        `create table if not exists security.object (\n  object_id bigint generated by default as identity primary key,\n  object_na text not null unique\n);`,
        `create table if not exists security.method (\n  method_id bigint generated by default as identity primary key,\n  object_id bigint not null references security.object(object_id) on delete cascade,\n  method_na text not null,\n  tx_nu integer not null,\n  constraint uq_method_object unique (object_id, method_na),\n  constraint uq_method_tx unique (tx_nu),\n  constraint ck_method_tx_positive check (tx_nu > 0)\n);`,
        `create table if not exists security.permission_method (\n  profile_id bigint not null references security.profile(profile_id) on delete cascade,\n  method_id bigint not null references security.method(method_id) on delete cascade,\n  primary key (profile_id, method_id)\n);`,
        `create index if not exists ix_user_profile_profile_id on security.user_profile(profile_id);`,
        `create index if not exists ix_method_object_id on security.method(object_id);`,
        `create index if not exists ix_permission_method_method_id on security.permission_method(method_id);`,
    ]
}

function sqlSecurityOptionalEmail() {
    return [
        `alter table security."user" add column if not exists user_em text;`,
        `create unique index if not exists uq_user_em on security."user"(user_em) where user_em is not null;`,
    ]
}

function sqlSecurityOperationalColumnsAndAudit() {
    return [
        // Conventional operational columns
        `alter table security.profile add column if not exists profile_na text;`,
        `create unique index if not exists uq_profile_na on security.profile(profile_na) where profile_na is not null;`,

        `alter table security."user" add column if not exists is_active boolean not null default true;`,
        `alter table security."user" add column if not exists created_at timestamptz not null default now();`,
        `alter table security."user" add column if not exists updated_at timestamptz not null default now();`,
        `alter table security."user" add column if not exists last_login_at timestamptz;`,

        // Safe, low-risk constraints (idempotent via DO blocks)
        `do $$ begin\n  alter table security.method add constraint ck_method_tx_positive check (tx_nu > 0);\nexception when duplicate_object then null; end $$;`,
        `do $$ begin\n  alter table security."user" add constraint ck_user_na_not_blank check (length(btrim(user_na)) > 0);\nexception when duplicate_object then null; end $$;`,

        // Audit log (optional to write to, but table is cheap and useful)
        `create table if not exists security.audit_log (\n  audit_id bigint generated by default as identity primary key,\n  time timestamptz not null default now(),\n  request_id text,\n  user_id bigint,\n  profile_id bigint,\n  action text not null,\n  object_na text,\n  method_na text,\n  tx_nu integer,\n  meta jsonb\n);`,
        `create index if not exists ix_audit_log_time on security.audit_log(time desc);`,
        `create index if not exists ix_audit_log_user_id on security.audit_log(user_id);`,
        `create index if not exists ix_audit_log_action on security.audit_log(action);`,
    ]
}

function sqlSessionTable(schemaName, tableName) {
    const schema = schemaName ?? 'public'
    const table = tableName ?? 'session'
    const qualified = schema === 'public' ? `public.${table}` : `${schema}.${table}`
    const prelude = schema !== 'public' ? [`create schema if not exists ${schema};`] : []
    return [
        ...prelude,
        `create table if not exists ${qualified} (\n  sid varchar not null primary key,\n  sess json not null,\n  expire timestamp(6) not null\n);`,
        `create index if not exists ${table}_expire_idx on ${qualified} (expire);`,
    ]
}

async function fileExists(p) {
    try {
        await fs.access(p)
        return true
    } catch {
        return false
    }
}

function parseAsyncMethodsFromBO(fileContent) {
    // We only want business methods defined as `async name(...)`.
    const methods = new Set()
    const re = /\basync\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(/g
    let m
    while ((m = re.exec(fileContent)) != null) {
        const name = m[1]
        if (!name) continue
        if (name === 'constructor') continue
        if (name.startsWith('_')) continue
        methods.add(name)
    }
    return Array.from(methods)
}

async function discoverBOs(repoRoot) {
    const boRoot = path.resolve(repoRoot, 'BO')
    if (!(await fileExists(boRoot))) return []

    const entries = await fs.readdir(boRoot, { withFileTypes: true })
    const objects = []
    for (const ent of entries) {
        if (!ent.isDirectory()) continue
        const objectName = ent.name
        const boFile = path.join(boRoot, objectName, `${objectName}BO.js`)
        if (!(await fileExists(boFile))) continue
        const content = await fs.readFile(boFile, 'utf8')
        const methods = parseAsyncMethodsFromBO(content)
        if (methods.length === 0) continue
        objects.push({ objectName, boFile, methods })
    }
    return objects
}

async function ensureProfile(client, profileId) {
    await client.query(
        'insert into security.profile (profile_id) values ($1) on conflict (profile_id) do nothing',
        [profileId]
    )
}

async function getNextTxFromDb(client) {
    const r = await client.query(
        'select coalesce(max(tx_nu), 0) + 1 as next_tx from security.method'
    )
    return Number(r.rows?.[0]?.next_tx)
}

async function upsertObject(client, objectName) {
    const r = await client.query(
        'insert into security.object (object_na) values ($1) on conflict (object_na) do update set object_na = excluded.object_na returning object_id',
        [objectName]
    )
    const objectId = r.rows?.[0]?.object_id
    if (!objectId) throw new Error(`Failed to upsert security.object for ${objectName}`)
    return objectId
}

async function upsertMethodKeepTx(client, { objectId, methodName, txNu }) {
    // If the method already exists, keep existing tx (don't overwrite contracts).
    const r = await client.query(
        `insert into security.method (object_id, method_na, tx_nu)
		 values ($1, $2, $3)
		 on conflict (object_id, method_na)
		 do update set tx_nu = security.method.tx_nu
		 returning method_id, tx_nu`,
        [objectId, methodName, txNu]
    )
    const row = r.rows?.[0]
    if (!row?.method_id) throw new Error(`Failed to upsert security.method for ${methodName}`)
    return { methodId: row.method_id, txNu: Number(row.tx_nu) }
}

async function grantPermission(client, { profileId, methodId }) {
    await client.query(
        'insert into security.permission_method (profile_id, method_id) values ($1, $2) on conflict (profile_id, method_id) do nothing',
        [profileId, methodId]
    )
}

async function registerBOs(client, { repoRoot, profileId, txStart }) {
    const bos = await discoverBOs(repoRoot)
    if (bos.length === 0) {
        console.log('No BOs discovered under ./BO (skipping BO registration).')
        return { registered: 0 }
    }

    await ensureProfile(client, profileId)

    let nextTx = txStart != null ? Number(txStart) : await getNextTxFromDb(client)
    if (!Number.isFinite(nextTx) || nextTx <= 0) nextTx = 1

    let registered = 0
    for (const bo of bos) {
        const objectId = await upsertObject(client, bo.objectName)
        for (const methodName of bo.methods) {
            // Pick a tx for new methods; if a tx collision happens (unlikely if nextTx is correct), retry.
            let attempts = 0
            while (attempts < 50) {
                try {
                    const { methodId, txNu } = await upsertMethodKeepTx(client, {
                        objectId,
                        methodName,
                        txNu: nextTx,
                    })
                    await grantPermission(client, { profileId, methodId })
                    registered++
                    // Only advance tx if we actually used it (i.e., method was new).
                    // If the method existed, txNu might be different; in both cases, move forward to keep new tx unique.
                    nextTx = Math.max(nextTx + 1, txNu + 1)
                    break
                } catch (err) {
                    const msg = String(err?.message || err)
                    // Unique tx constraint collision -> increment and retry.
                    if (
                        msg.toLowerCase().includes('uq_method_tx') ||
                        msg.toLowerCase().includes('unique') ||
                        msg.toLowerCase().includes('duplicate')
                    ) {
                        nextTx++
                        attempts++
                        continue
                    }
                    throw err
                }
            }
        }
    }

    console.log(`BO registration complete: ${registered} method(s) upserted/granted.`)
    return { registered }
}

async function promptYesNo(rl, question, defaultYes = false) {
    const suffix = defaultYes ? ' [Y/n] ' : ' [y/N] '
    const ans = String(await rl.question(question + suffix))
        .trim()
        .toLowerCase()
    if (!ans) return defaultYes
    return ['y', 'yes'].includes(ans)
}

async function promptText(rl, question, defaultValue) {
    const suffix = defaultValue != null ? ` (${defaultValue}) ` : ' '
    const ans = String(await rl.question(question + suffix)).trim()
    return ans.length > 0 ? ans : defaultValue
}

async function ensureAdminUser(client, { profileId, adminUser, adminHash }) {
    await client.query(
        'insert into security.profile (profile_id) values ($1) on conflict (profile_id) do nothing',
        [profileId]
    )

    const userResult = await client.query(
        'insert into security."user" (user_na, user_pw) values ($1, $2) on conflict (user_na) do update set user_pw = excluded.user_pw returning user_id',
        [adminUser, adminHash]
    )
    const userId = userResult.rows?.[0]?.user_id
    if (!userId) throw new Error('Failed to upsert admin user')

    await client.query(
        'insert into security.user_profile (user_id, profile_id) values ($1, $2) on conflict (user_id, profile_id) do nothing',
        [userId, profileId]
    )

    return { userId, profileId }
}

async function main() {
    const { opts } = parseArgs(process.argv.slice(2))
    if (opts.help) return printHelp()

    const tty = isTty()
    const nonInteractive = Boolean(opts.yes) || !tty

    const shouldPrint = Boolean(opts.print)
    const shouldApply = Boolean(opts.apply) || (!shouldPrint && tty)

    const sessionSchemaOpt = normalizeSchemaName(
        opts.sessionSchema ?? process.env.SESSION_SCHEMA ?? 'public'
    )
    const sessionTableOpt = normalizeTableName(
        opts.sessionTable ?? process.env.SESSION_TABLE ?? 'session'
    )

    const includeEmail = Boolean(opts.includeEmail)

    const seedAdminDefault = tty
    const seedAdmin = Boolean(opts.seedAdmin) || (opts.seedAdmin == null && seedAdminDefault)
    const adminUser = String(opts.adminUser ?? 'admin')
    const profileId = Number(opts.profileId ?? 1)

    const registerBoDefault = tty
    const registerBo = Boolean(opts.registerBo) || (opts.registerBo == null && registerBoDefault)
    const txStart = opts.txStart != null ? Number(opts.txStart) : undefined

    const sql = []
    sql.push(...sqlSecuritySchemaBase())
    if (includeEmail) sql.push(...sqlSecurityOptionalEmail())
    sql.push(...sqlSecurityOperationalColumnsAndAudit())
    sql.push(...sqlSessionTable(sessionSchemaOpt ?? 'public', sessionTableOpt ?? 'session'))

    if (shouldPrint) {
        console.log('-- Generated by scripts/db-init.mjs')
        console.log(sql.join('\n') + '\n')
        if (!shouldApply) return
    }

    if (!shouldApply) return

    const db = loadDbConfig()
    const client = new pg.Client(pgClientConfig(db))
    await client.connect()

    try {
        const info = await client.query(
            'select current_database() as db, inet_server_addr() as server_addr, inet_server_port() as server_port'
        )
        const dbName = info.rows?.[0]?.db
        const serverAddr = info.rows?.[0]?.server_addr
        const serverPort = info.rows?.[0]?.server_port

        if (!nonInteractive) {
            const rl = readline.createInterface({ input, output })
            try {
                console.log(`Connected to DB: ${dbName} @ ${serverAddr}:${serverPort}`)
                const ok = await promptYesNo(rl, 'Apply DB init statements?', true)
                if (!ok) return
            } finally {
                rl.close()
            }
        }

        await client.query('begin')
        for (const stmt of sql) {
            await client.query(stmt)
        }

        if (registerBo) {
            // Create profile ahead of time in case we want to grant perms, even if seedAdmin is off.
            await ensureProfile(client, profileId)
            await registerBOs(client, { repoRoot: process.cwd(), profileId, txStart })
        }

        if (seedAdmin) {
            let adminPassword = opts.adminPassword
            if (!adminPassword && !nonInteractive) {
                const rl = readline.createInterface({ input, output })
                try {
                    adminPassword = await promptText(rl, `Admin password for "${adminUser}"`, '')
                } finally {
                    rl.close()
                }
            }

            if (!adminPassword || String(adminPassword).length < 8) {
                throw new Error(
                    'Admin password is required (min 8 chars). Provide --adminPassword or run interactively.'
                )
            }

            const adminHash = await bcrypt.hash(String(adminPassword), 10)
            const { userId } = await ensureAdminUser(client, { profileId, adminUser, adminHash })
            console.log(
                `Seeded admin user: user_id=${userId}, user_na=${adminUser}, profile_id=${profileId}`
            )
        }

        await client.query('commit')
        console.log('DB init complete.')
        console.log(
            `Session table: ${sessionSchemaOpt ?? 'public'}.${sessionTableOpt ?? 'session'}`
        )
        if (includeEmail) console.log('Optional column enabled: security.user.user_em')
        if (registerBo)
            console.log(`BO methods auto-registered and granted to profile_id=${profileId}`)
    } catch (err) {
        try {
            await client.query('rollback')
        } catch {}
        console.error('DB init failed:', err?.message || err)
        process.exitCode = 1
    } finally {
        await client.end()
    }
}

export {
    // small helpers
    envBool,
    envInt,
    parseArgs,
    isTty,
    normalizeSchemaName,
    normalizeTableName,
    // SQL generators
    sqlSecuritySchemaBase,
    sqlSecurityOptionalEmail,
    sqlSecurityOperationalColumnsAndAudit,
    sqlSessionTable,
    // BO parsing
    parseAsyncMethodsFromBO,
    discoverBOs,
}

function isMainModule() {
    try {
        const entry = process.argv?.[1]
        if (!entry) return false
        return import.meta.url === pathToFileURL(entry).href
    } catch {
        return false
    }
}

if (isMainModule()) {
    await main()
}
